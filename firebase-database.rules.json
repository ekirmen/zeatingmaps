{
  "rules": {
    // REGLA GLOBAL: Denegar lectura y escritura por defecto para máxima seguridad.
    ".read": false,
    ".write": false,

    // Colección 'seats': Gestiona los asientos del mapa de eventos.
    "seats": {
      "$eventId": { // ID del evento (p. ej., "10")
        
        // Se permite la lectura de todos los asientos de un evento para mostrar el mapa.
        ".read": true,

        "$seatId": { // ID único del asiento (p. ej., "silla_c0b4c9ea...")
          
          // REGLA DE ESCRITURA: Define quién y bajo qué condiciones puede modificar un asiento.
          ".write": "auth != null && (
                      // Escenario 1: Un usuario ocupa un asiento que estaba disponible.
                      (data.child('status').val() === 'available' &&
                       newData.child('status').val() === 'occupied' &&
                       newData.child('reservedBy').val() === auth.uid)
                    ||
                      // Escenario 2: Un usuario libera un asiento que había ocupado.
                      (data.child('status').val() === 'occupied' &&
                       data.child('reservedBy').val() === auth.uid &&
                       newData.child('status').val() === 'available' &&
                       ( !newData.hasChild('reservedBy') || newData.child('reservedBy').val() === null ))
                    ||
                      // Escenario 3: Un administrador puede modificar cualquier asiento.
                      (auth.token.admin === true)
                    )
                    || (auth != null) // TEMPORARY: allow all authenticated users for testing
                    ",

          // REGLA DE VALIDACIÓN: Asegura que los datos del asiento tengan la estructura correcta.
          ".validate": "newData.hasChildren(['status', 'timestamp', 'seatDetails']) &&
                        newData.child('status').isString() &&
                        (newData.child('status').val() === 'available' || newData.child('status').val() === 'occupied' || newData.child('status').val() === 'locked') &&
                        newData.child('timestamp').isNumber() &&
                        // El campo 'reservedBy' solo debe existir si el asiento está ocupado.
                        (newData.child('status').val() === 'available' ? (!newData.hasChild('reservedBy') || newData.child('reservedBy').val() === null) : true)"
        }
      }
    },

    // Colección 'in-cart': Asientos temporales en el carrito de compras.
    "in-cart": {
      "$cart_id": { // Usualmente, este es el UID del usuario (auth.uid).
        // PERMISOS: Solo el propietario del carrito puede leerlo o escribir en él.
        ".read": "auth != null && auth.uid === $cart_id",
        ".write": "auth != null && auth.uid === $cart_id",

        "$seat_id": {
          ".indexOn": ["timestamp"],
          // VALIDACIÓN: Asegurar la estructura de los datos del carrito.
          ".validate": "newData.hasChildren(['status', 'timestamp', 'expires', 'seatDetails']) &&
                        newData.child('status').isString() &&
                        newData.child('timestamp').isNumber() &&
                        newData.child('expires').isNumber() &&
                        newData.child('seatDetails').hasChildren(['zona', 'precio', 'nombreMesa'])"
        }
      }
    },

    // Colección 'reserved': Reservas confirmadas y pagadas.
    "reserved": {
      "$userId": { // ID del usuario que realizó la reserva
        // PERMISOS: Solo el usuario propietario o un admin pueden acceder a estas reservas.
        ".read": "auth != null && auth.uid === $userId || auth.token.admin === true",
        ".write": "auth != null && auth.uid === $userId || auth.token.admin === true",
        
        "$reservation_id": {
          ".indexOn": ["timestamp"],
          // VALIDACIÓN: Asegurar la estructura de la reserva final.
          ".validate": "newData.hasChildren(['seatId', 'eventId', 'timestamp', 'status', 'purchaseDetails'])"
        }
      }
    },

    // Opcional: Colección para gestionar roles de administrador.
    "admins": {
      // Solo los administradores pueden ver la lista de otros administradores.
      ".read": "auth != null && auth.token.admin === true",
      // La escritura debe hacerse solo desde el backend (servidor o Cloud Function).
      ".write": false
    }
  }
}